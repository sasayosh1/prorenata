#!/usr/bin/env node

/**
 * Analytics Health Check (uses existing GA4/GSC export data)
 *
 * Reads:
 * - data/ga4_last30d.csv (generated by scripts/analytics/fetch-ga4-data.py)
 * - data/gsc_last30d.csv (generated by scripts/analytics/fetch-gsc-data.py)
 *
 * Detects:
 * - missing/stale data (often auth failure)
 * - zero / sudden drops (vs previous day / recent average)
 *
 * If abnormal: creates a GitHub Issue and exits 0 (non-failing).
 * If normal: does nothing and exits 0.
 *
 * Env:
 *   HEALTHCHECK_LOOKBACK_DAYS=7
 *   HEALTHCHECK_DROP_RATIO=0.2
 *   HEALTHCHECK_STALE_DAYS=4
 *   GITHUB_TOKEN=...
 *   GITHUB_REPOSITORY=owner/repo
 */

const fs = require('fs');
const path = require('path');

function appendGithubOutput(key, value) {
  const outputPath = process.env.GITHUB_OUTPUT;
  if (!outputPath) return;
  fs.appendFileSync(outputPath, `${key}=${String(value)}\n`, 'utf8');
}

function shouldCreateIssue() {
  const raw = process.env.HEALTHCHECK_CREATE_ISSUE;
  if (raw == null) return true;
  return !/^(false|0|no)$/i.test(String(raw).trim());
}

function mapReasonCode(reason) {
  switch (reason) {
    case 'ok':
      return 'OK';
    case 'missing_data':
      return 'MISSING_DATA';
    case 'stale_data':
      return 'STALE_DATA';
    case 'anomaly_detected':
      return 'ANOMALY';
    case 'script_error':
      return 'SCRIPT_ERROR';
    default:
      return 'UNKNOWN';
  }
}

function writeHealthFile(payload) {
  const dir = path.join(process.cwd(), 'analytics');
  const filePath = path.join(dir, 'health.json');
  fs.mkdirSync(dir, { recursive: true });
  fs.writeFileSync(filePath, JSON.stringify(payload, null, 2) + '\n', 'utf8');
}

function clampNumber(value, fallback) {
  const num = Number(value);
  return Number.isFinite(num) ? num : fallback;
}

function toDateStringUtc(date) {
  const year = date.getUTCFullYear();
  const month = String(date.getUTCMonth() + 1).padStart(2, '0');
  const day = String(date.getUTCDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function isoToYyyymmdd(iso) {
  return iso.replace(/-/g, '');
}

function mean(values) {
  const filtered = values.filter((v) => Number.isFinite(v));
  if (filtered.length === 0) return 0;
  return filtered.reduce((a, b) => a + b, 0) / filtered.length;
}

function parseCsv(content) {
  const rows = [];
  let row = [];
  let field = '';
  let inQuotes = false;

  const pushField = () => {
    row.push(field);
    field = '';
  };
  const pushRow = () => {
    rows.push(row);
    row = [];
  };

  for (let i = 0; i < content.length; i++) {
    const ch = content[i];

    if (inQuotes) {
      if (ch === '"') {
        const next = content[i + 1];
        if (next === '"') {
          field += '"';
          i++;
        } else {
          inQuotes = false;
        }
      } else {
        field += ch;
      }
      continue;
    }

    if (ch === '"') {
      inQuotes = true;
      continue;
    }

    if (ch === ',') {
      pushField();
      continue;
    }

    if (ch === '\r') {
      continue;
    }

    if (ch === '\n') {
      pushField();
      pushRow();
      continue;
    }

    field += ch;
  }

  // last line
  pushField();
  if (row.length > 1 || (row.length === 1 && row[0] !== '')) {
    pushRow();
  }

  const header = rows.shift() || [];
  const records = [];
  for (const r of rows) {
    if (r.length === 1 && r[0] === '') continue;
    const rec = {};
    for (let i = 0; i < header.length; i++) {
      rec[header[i]] = r[i] ?? '';
    }
    records.push(rec);
  }
  return records;
}

async function githubRequest(method, url, body) {
  const token = process.env.GITHUB_TOKEN;
  if (!token) throw new Error('GITHUB_TOKEN is required to create issues');

  const response = await fetch(url, {
    method,
    headers: {
      accept: 'application/vnd.github+json',
      authorization: `Bearer ${token}`,
      'x-github-api-version': '2022-11-28',
      'content-type': 'application/json',
      'user-agent': 'prorenata-analytics-health-check',
    },
    body: body ? JSON.stringify(body) : undefined,
  });

  const text = await response.text();
  const json = text ? JSON.parse(text) : null;
  if (!response.ok) {
    const message = json?.message || text || `HTTP ${response.status}`;
    throw new Error(`GitHub API error: ${message}`);
  }
  return json;
}

async function ensureIssue({ title, body, labels }) {
  const repo = process.env.GITHUB_REPOSITORY;
  if (!repo) throw new Error('GITHUB_REPOSITORY is required to create issues');
  const [owner, name] = repo.split('/');
  if (!owner || !name) throw new Error(`Invalid GITHUB_REPOSITORY: ${repo}`);

  const listUrl = `https://api.github.com/repos/${owner}/${name}/issues?state=open&per_page=100`;
  const issues = await githubRequest('GET', listUrl);
  const exists = issues.some((issue) => issue?.title === title);
  if (exists) return;

  const createUrl = `https://api.github.com/repos/${owner}/${name}/issues`;
  await githubRequest('POST', createUrl, { title, body, labels });
}

function evaluateSeries({ label, yesterday, dayBefore, recentAvg, dropRatio }) {
  const issues = [];

  // Skip anomaly detection if the metric is too small (normal variance for small sites)
  // For GSC clicks, if recent average is < 1.0 and yesterday is 0-1, this is normal variance
  const isGscClicks = label.includes('GSC clicks');
  if (isGscClicks && recentAvg < 1.0 && yesterday <= 1) {
    console.log(`‚ÑπÔ∏è  Skipping anomaly detection for ${label}: metric too small (recentAvg=${recentAvg.toFixed(2)}, yesterday=${yesterday})`);
    return issues; // Normal variance for small sites
  }

  if (yesterday === 0 && (dayBefore > 0 || recentAvg > 0)) {
    issues.push(`${label}: yesterday is 0 (dayBefore=${dayBefore}, recentAvg=${recentAvg.toFixed(2)})`);
  }

  if (dayBefore > 0) {
    const ratio = yesterday / dayBefore;
    if (ratio < dropRatio) {
      issues.push(`${label}: sudden drop vs dayBefore (yesterday=${yesterday}, dayBefore=${dayBefore}, ratio=${ratio.toFixed(2)})`);
    }
  }

  if (recentAvg > 0) {
    const ratio = yesterday / recentAvg;
    if (ratio < dropRatio) {
      issues.push(
        `${label}: sudden drop vs recentAvg (yesterday=${yesterday}, recentAvg=${recentAvg.toFixed(2)}, ratio=${ratio.toFixed(2)})`
      );
    }
  }

  return issues;
}

function loadCsvRecords(filePath) {
  if (!fs.existsSync(filePath)) return null;
  const content = fs.readFileSync(filePath, 'utf8');
  if (!content.trim()) return [];
  return parseCsv(content);
}

function latestIsoDateFromGsc(records) {
  let max = null;
  for (const r of records) {
    const d = r.date;
    if (!d || typeof d !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(d)) continue;
    if (!max || d > max) max = d;
  }
  return max;
}

function latestIsoDateFromGa4(records) {
  let max = null;
  for (const r of records) {
    const d = r.date;
    if (!d || typeof d !== 'string' || !/^\d{8}$/.test(d)) continue;
    const iso = `${d.slice(0, 4)}-${d.slice(4, 6)}-${d.slice(6, 8)}`;
    if (!max || iso > max) max = iso;
  }
  return max;
}

function sumByDate(records, dateKey, valueKey) {
  const map = new Map();
  for (const r of records) {
    const d = r[dateKey];
    if (!d) continue;
    const value = Number(r[valueKey] || 0);
    map.set(d, (map.get(d) || 0) + (Number.isFinite(value) ? value : 0));
  }
  return map;
}

async function main() {
  const lookbackDays = Math.max(3, Math.floor(clampNumber(process.env.HEALTHCHECK_LOOKBACK_DAYS, 7)));
  const dropRatio = clampNumber(process.env.HEALTHCHECK_DROP_RATIO, 0.2);
  // GSC "final" data often lags by ~2-3 days, so default stale window is 4 days.
  const staleDays = Math.max(1, Math.floor(clampNumber(process.env.HEALTHCHECK_STALE_DAYS, 4)));

  const ga4Path = path.join(process.cwd(), 'data', 'ga4_last30d.csv');
  const gscPath = path.join(process.cwd(), 'data', 'gsc_last30d.csv');

  const todayUtc = new Date();
  const yesterdayUtc = new Date(Date.UTC(todayUtc.getUTCFullYear(), todayUtc.getUTCMonth(), todayUtc.getUTCDate() - 1));
  const dayBeforeUtc = new Date(Date.UTC(todayUtc.getUTCFullYear(), todayUtc.getUTCMonth(), todayUtc.getUTCDate() - 2));
  const yIso = toDateStringUtc(yesterdayUtc);
  const dIso = toDateStringUtc(dayBeforeUtc);

  const ga4Records = loadCsvRecords(ga4Path);
  const gscRecords = loadCsvRecords(gscPath);

  if (!ga4Records || !gscRecords) {
    const missing = [!ga4Records ? 'data/ga4_last30d.csv' : null, !gscRecords ? 'data/gsc_last30d.csv' : null]
      .filter(Boolean)
      .join(', ');

    writeHealthFile({
      ok: false,
      reason: 'missing_data',
      reason_code: mapReasonCode('missing_data'),
      checkedAt: new Date().toISOString(),
      dateCheckedUtc: yIso,
      missing,
    });

    const title = 'üìâ Analytics health-check failed (missing data)';
    const body = [
      '## Analytics Health Check',
      '',
      'Required analytics export files are missing.',
      '',
      `- Missing: ${missing}`,
      `- Date checked (UTC): \`${yIso}\``,
      '',
      '### Likely causes',
      '- Daily analytics workflow did not run / failed',
      '- Credentials/auth failure prevented data export',
      '',
      '### Action',
      '- Check `Daily Analytics & SEO Report` workflow logs.',
      '- Fix GA4/GSC credentials if needed.',
      '',
      `Timestamp: ${new Date().toISOString()}`,
    ].join('\n');

    if (shouldCreateIssue()) {
      try {
        await ensureIssue({ title, body, labels: ['analytics', 'automated'] });
      } catch (error) {
        console.warn('‚ö†Ô∏è Failed to create issue:', error?.message || error);
      }
    }

    appendGithubOutput('healthy', 'false');
    appendGithubOutput('reason', 'missing_data');
    appendGithubOutput('reason_code', mapReasonCode('missing_data'));
    process.exit(0);
  }

  const latestGsc = latestIsoDateFromGsc(gscRecords);
  const latestGa4 = latestIsoDateFromGa4(ga4Records);

  const staleCutoff = new Date(Date.UTC(todayUtc.getUTCFullYear(), todayUtc.getUTCMonth(), todayUtc.getUTCDate() - staleDays));
  const staleIso = toDateStringUtc(staleCutoff);

  if (!latestGsc || !latestGa4 || latestGsc < staleIso || latestGa4 < staleIso) {
    writeHealthFile({
      ok: false,
      reason: 'stale_data',
      reason_code: mapReasonCode('stale_data'),
      checkedAt: new Date().toISOString(),
      dateCheckedUtc: yIso,
      staleThresholdUtc: staleIso,
      latest: { gsc: latestGsc || null, ga4: latestGa4 || null },
    });

    const title = 'üìâ Analytics health-check failed (stale data)';
    const body = [
      '## Analytics Health Check',
      '',
      'Analytics export files look stale (often auth failure or workflow not running).',
      '',
      `- Date checked (UTC): \`${yIso}\``,
      `- Stale threshold: < \`${staleIso}\``,
      `- Latest in GSC CSV: \`${latestGsc || 'N/A'}\``,
      `- Latest in GA4 CSV: \`${latestGa4 || 'N/A'}\``,
      '',
      '### Action',
      '- Check `Daily Analytics & SEO Report` workflow.',
      '- Fix GA4/GSC credentials and rerun if necessary.',
      '- Optimization workflows should be skipped until analytics is healthy.',
      '',
      `Timestamp: ${new Date().toISOString()}`,
    ].join('\n');

    if (shouldCreateIssue()) {
      try {
        await ensureIssue({ title, body, labels: ['analytics', 'automated'] });
      } catch (error) {
        console.warn('‚ö†Ô∏è Failed to create issue:', error?.message || error);
      }
    }

    appendGithubOutput('healthy', 'false');
    appendGithubOutput('reason', 'stale_data');
    appendGithubOutput('reason_code', mapReasonCode('stale_data'));
    process.exit(0);
  }

  const ga4ByDate = sumByDate(ga4Records, 'date', 'sessions'); // date: YYYYMMDD
  const gscByDate = sumByDate(gscRecords, 'date', 'clicks'); // date: YYYY-MM-DD

  const ga4Y = Number(ga4ByDate.get(isoToYyyymmdd(yIso)) || 0);
  const ga4D = Number(ga4ByDate.get(isoToYyyymmdd(dIso)) || 0);
  const gscY = Number(gscByDate.get(yIso) || 0);
  const gscD = Number(gscByDate.get(dIso) || 0);

  const ga4Recent = [];
  const gscRecent = [];
  for (let offset = 2; offset <= lookbackDays + 1; offset++) {
    const dt = new Date(Date.UTC(todayUtc.getUTCFullYear(), todayUtc.getUTCMonth(), todayUtc.getUTCDate() - offset));
    const iso = toDateStringUtc(dt);
    ga4Recent.push(Number(ga4ByDate.get(isoToYyyymmdd(iso)) || 0));
    gscRecent.push(Number(gscByDate.get(iso) || 0));
  }

  const ga4Avg = mean(ga4Recent);
  const gscAvg = mean(gscRecent);

  const problems = [
    ...evaluateSeries({ label: 'GA4 sessions', yesterday: ga4Y, dayBefore: ga4D, recentAvg: ga4Avg, dropRatio }),
    ...evaluateSeries({ label: 'GSC clicks', yesterday: gscY, dayBefore: gscD, recentAvg: gscAvg, dropRatio }),
  ];

  if (problems.length > 0) {
    writeHealthFile({
      ok: false,
      reason: 'anomaly_detected',
      reason_code: mapReasonCode('anomaly_detected'),
      checkedAt: new Date().toISOString(),
      dateCheckedUtc: yIso,
      thresholds: { lookbackDays, dropRatio, staleDays },
      metrics: {
        ga4: { yesterdaySessions: ga4Y, dayBeforeSessions: ga4D, recentAvgSessions: ga4Avg },
        gsc: { yesterdayClicks: gscY, dayBeforeClicks: gscD, recentAvgClicks: gscAvg },
      },
      problems,
    });

    const title = `üìâ Analytics anomaly detected ${yIso}`;
    const body = [
      '## Analytics Health Check',
      '',
      'Abnormal values detected. Optimization workflows should be skipped for this run.',
      '',
      `- Date checked (UTC): \`${yIso}\``,
      `- Lookback days: \`${lookbackDays}\``,
      `- Drop ratio threshold: \`${dropRatio}\``,
      '',
      '### Metrics',
      `- GA4 sessions: yesterday=${ga4Y}, dayBefore=${ga4D}, recentAvg=${ga4Avg.toFixed(2)}`,
      `- GSC clicks: yesterday=${gscY}, dayBefore=${gscD}, recentAvg=${gscAvg.toFixed(2)}`,
      '',
      '### Detected Problems',
      ...problems.map((p) => `- ${p}`),
      '',
      `Timestamp: ${new Date().toISOString()}`,
    ].join('\n');

    if (shouldCreateIssue()) {
      try {
        await ensureIssue({ title, body, labels: ['analytics', 'automated'] });
      } catch (error) {
        console.warn('‚ö†Ô∏è Failed to create issue:', error?.message || error);
      }
    }

    appendGithubOutput('healthy', 'false');
    appendGithubOutput('reason', 'anomaly_detected');
    appendGithubOutput('reason_code', mapReasonCode('anomaly_detected'));
    process.exit(0);
  }

  console.log('‚úÖ Analytics healthy');
  console.log(`- Date (UTC): ${yIso}`);
  console.log(`- GA4 sessions: ${ga4Y}`);
  console.log(`- GSC clicks: ${gscY}`);

  writeHealthFile({
    ok: true,
    reason: 'ok',
    reason_code: mapReasonCode('ok'),
    checkedAt: new Date().toISOString(),
    dateCheckedUtc: yIso,
    thresholds: { lookbackDays, dropRatio, staleDays },
    metrics: {
      ga4: { yesterdaySessions: ga4Y, dayBeforeSessions: ga4D, recentAvgSessions: ga4Avg },
      gsc: { yesterdayClicks: gscY, dayBeforeClicks: gscD, recentAvgClicks: gscAvg },
    },
  });

  appendGithubOutput('healthy', 'true');
  appendGithubOutput('reason', 'ok');
  appendGithubOutput('reason_code', mapReasonCode('ok'));
}

main().catch((error) => {
  console.error('‚ùå analytics-health-check failed:', error?.message || error);
  try {
    const date = toDateStringUtc(new Date());
    writeHealthFile({
      ok: false,
      reason: 'script_error',
      reason_code: mapReasonCode('script_error'),
      checkedAt: new Date().toISOString(),
      dateCheckedUtc: date,
      error: String(error?.message || error),
    });
    const title = 'üìâ Analytics health-check failed (script error)';
    const body = [
      '## Analytics Health Check',
      '',
      'Script failed before completing checks (configuration or runtime error).',
      '',
      `- Date (UTC): \`${date}\``,
      '',
      '### Error',
      '```',
      String(error?.message || error),
      '```',
      '',
      '### Action',
      '- Verify the daily analytics export is running and data files are valid.',
      '- Optimization workflows should be skipped until this is resolved.',
      '',
      `Timestamp: ${new Date().toISOString()}`,
    ].join('\n');

    if (shouldCreateIssue()) {
      ensureIssue({ title, body, labels: ['analytics', 'automated'] }).catch(() => { });
    }
  } catch {
    // ignore
  }

  appendGithubOutput('healthy', 'false');
  appendGithubOutput('reason', 'script_error');
  appendGithubOutput('reason_code', mapReasonCode('script_error'));
  process.exit(0);
});
